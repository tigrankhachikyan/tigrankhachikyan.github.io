---
title: "PostgreSQL: GENERATED IDENTITY vs SERIAL Primary Keys - A Modern Developer's Guide"
date: 2025-08-05T10:16:37Z
tags:
- postgresql
- sql
- database
- identity
- serial
- primary key
- auto-increment
categories:
- cheatsheet
author: Me
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
description: "Explore the differences between PostgreSQL's SERIAL and GENERATED AS IDENTITY primary keys. Understand their implications for modern database design, including standards compliance, manual value control, and sequence behavior."
disableHLJS: false
disableShare: false
hideSummary: false
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowWordCount: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
cover:
  image: "<image path/url>"
  alt: "<alt text>"
  caption: "<text>"
  relative: false
  hidden: true

---
# PostgreSQL: GENERATED IDENTITY vs SERIAL Primary Keys - A Modern Developer's Guide

When creating auto-incrementing primary keys in PostgreSQL, developers typically encounter two main approaches: the traditional `SERIAL` type and the newer `GENERATED AS IDENTITY` columns. While both accomplish the same basic goal, understanding their differences is crucial for making informed architectural decisions.

## The Traditional SERIAL Approach

The `SERIAL` type has been PostgreSQL's go-to solution for auto-incrementing keys for decades:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email VARCHAR(255) UNIQUE
);
```

Under the hood, PostgreSQL creates several objects when you use `SERIAL`:
- A sequence with the naming pattern `{table}_{column}_seq`
- A default value using `nextval()` function
- Ownership relationship between the sequence and column

### How SERIAL Handles Sequence Generation

When you create a `SERIAL` column, PostgreSQL automatically:

1. **Creates a sequence**: `CREATE SEQUENCE users_id_seq`
2. **Sets column default**: `ALTER TABLE users ALTER COLUMN id SET DEFAULT nextval('users_id_seq')`
3. **Establishes ownership**: `ALTER SEQUENCE users_id_seq OWNED BY users.id`

This means the sequence lifecycle is tied to the column - drop the column, and the sequence disappears too.

## The Modern GENERATED AS IDENTITY Standard

Introduced in PostgreSQL 10, `GENERATED AS IDENTITY` follows the SQL:2003 standard:

```sql
-- Strict identity column
CREATE TABLE users (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    email VARCHAR(255) UNIQUE
);

-- Flexible identity column
CREATE TABLE products (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    price DECIMAL(10,2)
);
```

### Identity Column Variants

**GENERATED ALWAYS AS IDENTITY**
- Prevents manual value insertion
- System always generates the next value
- Requires `OVERRIDING SYSTEM VALUE` for manual insertion

**GENERATED BY DEFAULT AS IDENTITY**
- Allows manual value insertion
- System generates values only when none provided
- Behaves similarly to SERIAL

## Key Differences Breakdown

### Standards Compliance
- **SERIAL**: PostgreSQL-specific extension
- **IDENTITY**: SQL standard compliant, portable across databases

### Manual Value Control
```sql
-- SERIAL - allows manual insertion
INSERT INTO serial_table (id, name) VALUES (100, 'Manual ID');

-- GENERATED ALWAYS - prevents manual insertion
INSERT INTO always_table (id, name) VALUES (100, 'Manual ID'); -- ERROR

-- GENERATED BY DEFAULT - allows manual insertion
INSERT INTO default_table (id, name) VALUES (100, 'Manual ID'); -- OK
```

### Sequence Behavior
Both create sequences, but identity columns provide more control:

```sql
-- Identity with custom sequence options
CREATE TABLE orders (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1000
        INCREMENT BY 1
        MINVALUE 1000
        MAXVALUE 999999
        CACHE 20
    ) PRIMARY KEY,
    total DECIMAL(10,2)
);
```

## Disadvantages of SERIAL

### 1. Non-Standard SQL
The biggest drawback of `SERIAL` is its PostgreSQL-specific nature. If you ever need to migrate to another database system, you'll need to rewrite these column definitions.

### 2. Implicit Sequence Creation
SERIAL creates sequences behind the scenes with predictable names, which can lead to:
- **Naming conflicts** in complex schemas
- **Unclear dependencies** when examining database structure
- **Maintenance challenges** when sequences need modification

### 3. Sequence Generation Quirks

**Gap Creation**: SERIAL sequences can create gaps in numbering:
```sql
BEGIN;
INSERT INTO users (name) VALUES ('Alice'); -- Gets ID 1
ROLLBACK; -- Transaction rolled back, but sequence advanced

INSERT INTO users (name) VALUES ('Bob'); -- Gets ID 2, not 1
```

**Manual Insertion Issues**: When you manually insert values, the sequence doesn't automatically adjust:
```sql
INSERT INTO users (id, name) VALUES (50, 'Manual User');
INSERT INTO users (name) VALUES ('Auto User'); -- Might get ID 1, causing conflict later
```

**Sequence Synchronization**: After manual insertions, you often need to manually sync the sequence:
```sql
SELECT setval('users_id_seq', (SELECT MAX(id) FROM users));
```

### 4. Limited Introspection
With SERIAL, the auto-increment behavior isn't immediately obvious from the table definition. You need to examine the column default to understand the behavior.

### 5. Backup and Restore Complications
SERIAL sequences can cause issues during backup/restore operations, especially when restoring partial data or when sequences get out of sync with actual data.

## Identity Columns: The Better Choice

Identity columns address most of SERIAL's shortcomings:

### Explicit Declaration
```sql
-- Clear intent and behavior
CREATE TABLE customers (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL
);
```

### Better Control
```sql
-- Restart sequence without complex SQL
ALTER TABLE customers ALTER COLUMN id RESTART WITH 1000;

-- Change increment
ALTER TABLE customers ALTER COLUMN id SET INCREMENT BY 5;
```

### Safer Manual Insertion
Identity columns with `BY DEFAULT` handle manual insertions more gracefully, automatically adjusting the internal sequence when needed.

## Migration Strategy

If you're working with existing SERIAL columns, you can convert them:

```sql
-- Convert SERIAL to IDENTITY
ALTER TABLE users ALTER COLUMN id DROP DEFAULT;
DROP SEQUENCE users_id_seq;
ALTER TABLE users ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
```

## Recommendations

### For New Projects
- Use `GENERATED BY DEFAULT AS IDENTITY` as your default choice
- Use `GENERATED ALWAYS AS IDENTITY` when you want strict control over ID generation
- Avoid SERIAL unless you have specific PostgreSQL-only requirements

### For Existing Projects
- SERIAL columns work fine and don't require immediate migration
- Consider converting to identity columns during major schema updates
- Be aware of the behavioral differences when adding new tables

## Conclusion

While SERIAL has served PostgreSQL developers well for years, `GENERATED AS IDENTITY` represents the modern, standards-compliant approach to auto-incrementing primary keys. The explicit syntax, better control over sequence behavior, and improved portability make identity columns the preferred choice for new development.

The transition from SERIAL to identity columns reflects PostgreSQL's broader movement toward SQL standard compliance while maintaining backward compatibility. By understanding both approaches, you can make informed decisions about which pattern best fits your application's needs.

## References
- [PostgreSQL Documentation: Identity Columns](https://www.postgresql.org/docs/current/ddl-identity-columns.html)
